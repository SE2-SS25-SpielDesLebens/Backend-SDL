package at.aau.serg.websocketserver.board;

import org.springframework.stereotype.Service;
import org.springframework.beans.factory.annotation.Autowired;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

/**
 * Service zur Verwaltung der Spiellogik und Spielerpositionen auf dem Spielbrett.
 */
@Service
public class BoardService {
    private final List<Field> board;
    private final Map<String, Integer> playerPositions = new ConcurrentHashMap<>();  // playerId → fieldIndex
    private final BoardDataProvider boardDataProvider;

    /**
     * Erzeugt einen neuen BoardService mit einer Spring-Injection des BoardDataProviders.
     *
     * @param boardDataProvider Provider für die Spielbrettdaten
     */
    @Autowired
    public BoardService(BoardDataProvider boardDataProvider) {
        this.boardDataProvider = boardDataProvider;
        this.board = boardDataProvider.getBoard();
    }
    
    /**
     * Konstruktor für Testzwecke, ermöglicht das Injizieren eines Mock-BoardDataProviders.
     * 
     * @param boardDataProvider Ein Mock-Provider für die Tests
     * @param playerPositions Vorgefertigte Spielerpositionen für Tests
     */
    protected BoardService(BoardDataProvider boardDataProvider, Map<String, Integer> playerPositions) {
        this.boardDataProvider = boardDataProvider;
        this.board = boardDataProvider.getBoard();
        if (playerPositions != null) {
            this.playerPositions.putAll(playerPositions);
        }
    }

    /**
     * Fügt einen Spieler zum Board hinzu und platziert ihn auf dem angegebenen Startfeld.
     *
     * @param playerId Die ID des Spielers
     * @param startFieldIndex Der Index des Startfeldes
     */
    public void addPlayer(String playerId, int startFieldIndex) {
        playerPositions.put(playerId, startFieldIndex);
    }

    /**
     * Fügt einen Spieler zum Board hinzu und platziert ihn auf dem angegebenen Startfeld.
     *
     * @param playerId Die ID des Spielers als Integer
     * @param startFieldIndex Der Index des Startfeldes
     */
    public void addPlayer(int playerId, int startFieldIndex) {
        // Wandelt die Integer-ID in einen String um
        String playerIdStr = String.valueOf(playerId);
        // Ruft die ursprüngliche Methode mit der String-ID auf
        addPlayer(playerIdStr, startFieldIndex);
    }

    /**
     * Bewegt einen Spieler um die angegebene Anzahl an Schritten vorwärts.
     *
     * @param playerId Die ID des Spielers als Integer
     * @param steps Die Anzahl der Schritte
     */
    public void movePlayer(int playerId, int steps) {
        // Wandelt die Integer-ID in einen String um
        String playerIdStr = String.valueOf(playerId);
        // Ruft die ursprüngliche Methode mit der String-ID auf
        movePlayer(playerIdStr, steps);
    }

    /**
     * Bewegt einen Spieler um die angegebene Anzahl an Schritten vorwärts.
     *
     * @param playerId Die ID des Spielers
     * @param steps Die Anzahl der Schritte
     */
    public void movePlayer(String playerId, int steps) {
        // Berechne alle möglichen Zielfelder
        List<Integer> moveOptions = getMoveOptions(playerId, steps);
        
        // Aktualisiere die Position des Spielers
        if (!moveOptions.isEmpty()) {
            // Bei nur einer Option wird der Spieler direkt dorthin bewegt
            // Bei mehreren Optionen nehmen wir die erste Option, um Abwärtskompatibilität für Tests zu gewährleisten
            // Die eigentliche Spiellogik verwendet getMoveOptions + movePlayerToField
            int targetFieldIndex = moveOptions.get(0);
            playerPositions.put(playerId, targetFieldIndex);
        }
    }

    /**
     * Bewegt einen Spieler um die angegebene Anzahl an Schritten mit Entscheidungslogik für Verzweigungen.
     *
     * @param playerId Die ID des Spielers
     * @param steps Die Anzahl der Schritte
     * @return Die Liste der möglichen Zielfelder nach dem Würfelwurf
     */
    public List<Integer> getMoveOptions(String playerId, int steps) {
        int currentFieldIndex = playerPositions.getOrDefault(playerId, 1);
        Field currentField = getFieldByIndex(currentFieldIndex);
        
        // Liste der möglichen nächsten Felder
        List<Integer> result = new ArrayList<>();
        
        // Wenn kein Feld gefunden wurde oder es keine nextFields hat, leere Liste zurückgeben
        if (currentField == null || currentField.getNextFields().isEmpty()) {
            return result;
        }
        
        // Die nextFields-Liste des aktuellen Feldes abrufen
        List<Integer> nextFields = currentField.getNextFields();
        
        // Bestimme das Zielfeld basierend auf dem Würfelwert (steps)
        if (steps <= nextFields.size()) {
            // Wenn der Würfelwert kleiner oder gleich der Anzahl der nextFields ist,
            // nehmen wir den Eintrag an der Position (steps - 1)
            // (weil Listen in Java bei 0 beginnen)
            result.add(nextFields.get(steps - 1));
        } else {
            // Wenn der Würfelwert größer ist als die Anzahl der nextFields,
            // nehmen wir den letzten verfügbaren Eintrag
            result.add(nextFields.get(nextFields.size() - 1));
        }
        
        return result;
    }

    /**
     * Bewegt einen Spieler direkt zu einem bestimmten Feld.
     *
     * @param playerId Die ID des Spielers
     * @param targetFieldIndex Der Index des Zielfelds
     * @return true, wenn die Bewegung erfolgreich war, false sonst
     */
    public boolean movePlayerToField(String playerId, int targetFieldIndex) {
        int currentFieldIndex = playerPositions.getOrDefault(playerId, 1);
        Field currentField = getFieldByIndex(currentFieldIndex);
        
        // Prüfe, ob das Zielfeld ein erlaubtes nächstes Feld ist
        if (currentField != null && currentField.getNextFields().contains(targetFieldIndex)) {
            playerPositions.put(playerId, targetFieldIndex);
            return true;
        }
        return false;
    }
    
    /**
     * Gibt das Feld zurück, auf dem sich der Spieler gerade befindet.
     *
     * @param playerId Die ID des Spielers
     * @return Das Feld, auf dem sich der Spieler befindet
     */
    public Field getPlayerField(Object playerId) {
        String playerIdStr = String.valueOf(playerId);
        int fieldIndex = playerPositions.getOrDefault(playerIdStr, 1);
        return getFieldByIndex(fieldIndex);
    }
    
    /**
     * Gibt alle Felder zurück, die von der aktuellen Position des Spielers aus erreichbar sind.
     *
     * @param playerId Die ID des Spielers
     * @return Eine Liste aller Felder, die vom Spieler erreicht werden können
     */
    public List<Field> getValidNextFields(String playerId) {
        Field currentField = getPlayerField(playerId);
        List<Field> validFields = new ArrayList<>();
        
        if (currentField != null) {
            for (Integer nextFieldIndex : currentField.getNextFields()) {
                Field nextField = getFieldByIndex(nextFieldIndex);
                if (nextField != null) {
                    validFields.add(nextField);
                }
            }
        }
        
        return validFields;
    }

    /**
     * Setzt die Position eines Spielers direkt auf ein bestimmtes Feld.
     * Diese Methode prüft NICHT, ob die Position gültig ist.
     *
     * @param playerId Die ID des Spielers
     * @param fieldIndex Der Index des Zielfelds
     */
    public void setPlayerPosition(int playerId, int fieldIndex) {
        playerPositions.put(String.valueOf(playerId), fieldIndex);
    }

    /**
     * Gibt ein Feld anhand seines Indexes zurück.
     *
     * @param index Der Index des Feldes
     * @return Das Feld mit dem angegebenen Index oder null, wenn kein Feld mit diesem Index existiert
     */
    private Field getFieldByIndex(int index) {
        return boardDataProvider.getFieldByIndex(index);
    }

    /**
     * Gibt die Liste aller Felder auf dem Spielbrett zurück.
     *
     * @return Eine unveränderbare Liste aller Felder
     */
    public List<Field> getBoard() {
        return Collections.unmodifiableList(board);
    }

    /**
     * Gibt die Anzahl der Felder auf dem Spielbrett zurück.
     *
     * @return Die Anzahl der Felder
     */
    public int getBoardSize() {
        return board.size();
    }
}
